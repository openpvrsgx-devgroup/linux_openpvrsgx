#
# initialite Solomon SSD2858 chip with input stream from OMAP5 and panel chained to the output
# using the panel-mipi-debug driver
#
# -r:	program for rotation
# -l:	loop dcs commands 10h and 11h to check LP output to panel
# -p:	program panel
# -s:	enable stream to ssd and panel

if ! [ "$(cat /proc/device-tree/ocp/dss@58000000/encoder@58004000/lcd/compatible)" = "omapdss,mipi,debug" ]
then
	echo this script needs the mipi-debug driver!
	echo use ./panelselect and choose the 'n' driver
	exit 1
fi

./bl 1

if [ ! -L dcs ]
then
	rm -rf dcs
	ln -s /sys/devices/44000000.ocp/58000000.dss/58004000.encoder/58004000.encoder:lcd/dcs dcs
fi

# make sure the panel is active before trying to send commands
echo nostream >dcs	# if it was on before
echo stop >dcs	# stop if it was already running
echo nopower >dcs	# enable is unused
echo reset >dcs	# reset panel
# reset panel
echo reset >dcs	# reset panel
echo power >dcs	# enable ssd (should do this only on v4 boards!!! but I have no method to decide between v3 and v4)

sleep .1
echo noreset >dcs	# take panel out of reset before starting the clocks
sleep .1

case "$1" in
"-r" )

echo start x_res=1280 y_res=720 lpclock=12000000 >dcs	# start MIPI interface timing for rotation
sleep .1

# show some DCS status (don't use echo status >dcs because it reads non-existent registers which makes the communication hang)
for i in 0b 0c 45
	do echo $i r >dcs
done

# now program the ssd chip

echo g0004 rrrr >dcs
echo g0008 rrrr >dcs
echo g000c rrrr >dcs
echo g0010 rrrr >dcs
echo g0014 rrrr >dcs
echo g001c rrrr >dcs
echo g0020 rrrr >dcs
echo g0024 rrrr >dcs
echo g0028 rrrr >dcs
echo g002c rrrr >dcs
echo g0030 rrrr >dcs

# rotate example
# start with SCM
echo g0008 01f40132 >dcs	# SCM_PLL (01F40132): default = POSTDIV=2 MULT=50 => 600 MHz
echo g000c 00000001 >dcs	# SCM_CC (00000003): MTXDIV=1 (=> 600 MHz) SYSDIV=2 (=> 300 MHz)
echo g0014 0c37800f >dcs	# SCM_MISC2 (0C77800F): MRXEN = enabled
# echo g0020 1592577d >dcs	# SCM_ANACTRL1 (1592567D): CPUNR = enabled (what is this good for?)
echo g0024 00003000 >dcs	# SCM_ANACTRL2 (00003300): CPPER=24
echo g0014 rrrr >dcs
echo g0020 rrrr >dcs

# some DCS
echo 11 >dcs
echo 2a 000004ff >dcs
echo 2b 000002cf >dcs

# MIPIRX
echo g1008 01200445 >dcs	# MIPIRX_DCR (01200245): HST=4

# VTCM
echo g200c 00000302 >dcs	# VCTM_CFGR (00000000): SPLIT_MEM=1, ROT90=1, TE_SEL=1
echo g2010 00040001 >dcs	# VCTM_PCFRR (00010001): PCLKDEN=4 PCLKNUM=1
echo g2014 0366004c >dcs
echo g2018 051e0010 >dcs
echo g201c 02d00500 >dcs
echo g2020 050002d0 >dcs
echo g2024 050002d0 >dcs
echo g203c 050002d0 >dcs
echo g2034 00000000 >dcs
echo g2038 04ff02cf >dcs
echo g2030 00000015 >dcs
echo g20a0 00000050 >dcs
echo g2014 rrrr >dcs
echo g2038 rrrr >dcs

# MIPITX
# echo g6008 00c90008 >dcs	# MIPITX_CTLR (00030008): LS_OUT=4 lanes; LPD=9
echo g6008 00c90009 >dcs	# MIPITX_CTLR (00030008): LS_OUT=4 lanes; LPD=9; CKE
# echo g600c 02d00500 >dcs	# MIPITX_VTC1R (0214020A):
echo g600c 329e3c05 >dcs	# MIPITX_VTC1R (0214020A): HSA=5 VSA=60 HBP=158 VBP=50
# echo g6010 104c0202 >dcs	# MIPITX_VTC2R (0438020A):
echo g6010 05003205 >dcs	# MIPITX_VTC2R (0438020A): HFP=5 VFP=50 VACT=1280
echo g6014 01000102 >dcs	# MIPITX_VCFR (01000101): VM=burst mode
echo g6084 000002d0 >dcs	# MIPITX_DSI0VR (00000400): HACT=720
echo g6010 rrrr >dcs
shift
;;

* )

echo start x_res=720 y_res=1280 lpclock=12000000 >dcs	# start MIPI interface timing for pass-through
sleep .1

# show some DCS status (don't use echo status >dcs because it reads non-existent registers which makes the chip hang)
for i in 0b 0c 45
	do echo $i r >dcs
done

# DCS sleep out
echo 11 >dcs

# now program the ssd chip

# registers
# 0000   SCM
# 1000   MIPIRX
# 2000   VTCM
# 4000   VCU
# 5000   GPIO
# 6000   MIPITX

# fixme: can we use bash hex arithmetic to do the required calculations e.g. for clock dividers?
# something like echo g0008 $(($POSTDIV<<8 | $MULT<<2))
# but: $(()) expands to a decimal result

# start with SCM
echo g0008 01f4012a >dcs	# SCM_PLL (01F40132): default = POSTDIV=2 MULT=42 => 504 MHz
echo g000c 00000000 >dcs	# SCM_CC (00000003): MTXDIV=0 (:1 => 504 MHz) SYSDIV=0 (:1 => 252 MHz)
echo g0014 0C3F800F >dcs	# SCM_MISC2: default + MRXEN = enabled + MRXVB
echo g0024 00003000 >dcs	# SCM_ANACTRL2 (00003300): CPPER=24
echo g0014 rrrr >dcs
echo g0020 rrrr >dcs

# MIPIRX
echo g1008 01200445 >dcs	# MIPIRX_DCR (01200245): HST=4

# VCTM
echo g200c 00000006 >dcs	# VCTM_CFGR (00000000): VBP=1, TE_SEL=1
echo g2010 00a80033 >dcs	# VCTM_PCFRR (00010001): PCLKNUM=51 PCLKNUM=168 => 76.5 MHz

# MIPITX
# echo g6008 00c60009 >dcs	# MIPITX_CTLR (00030008): LS_OUT=4 lanes; LPD=6 (63:7 => 9 MHz); CKE
echo g6008 00c90009 >dcs	# MIPITX_CTLR (00030008): LS_OUT=4 lanes; LPD=9 (76:9 => 8.4 MHz); CKE
echo g600c 329e3c05 >dcs	# MIPITX_VTC1R (0214020A): HSA=5 VSA=60 HBP=158 VBP=50
echo g6010 05003205 >dcs	# MIPITX_VTC2R (0438020A): HFP=5 VFP=50 VACT=1280
echo g6014 01000102 >dcs	# MIPITX_VCFR (01000101): VM=burst mode
echo g6084 000002d0 >dcs	# MIPITX_DSI0VR (00000400): HACT=720
echo g6010 rrrr >dcs

;;

esac

if [ "$1" = "-l" ]
then

# this tries to forward DCS commands to the panel
# so that it is possible to inspect the waveforms
# generated by the SSD2858 at the panel interface

	echo gff01 >dcs	# enable forwarding through ssd

	while true	# will never exit!
	do
		echo 11 >dcs
		sleep 0.02
		echo 10 >dcs
		sleep 0.02
	done
	shift
fi

if [ "$1" = "-p" ]
then	# program panel

	echo gff01 >dcs	# enable forwarding through ssd

	echo status >dcs
	for i in 0b 0c 45
		do echo $i r >dcs
	done
	shift
fi

if [ "$1" = "-s" ]
then	# enable stream

	echo gff00 >dcs	# address the ssd

	echo stream >dcs
	echo 11 >dcs
	sleep .1
	echo 29 >dcs

	echo gff01 >dcs	# enable forwarding through ssd
	echo 11 >dcs
	sleep .1
	echo 29 >dcs

	echo gff00 >dcs	# address the ssd

fi
